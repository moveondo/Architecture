### 1,盒子模型

CSS css盒子模型 又称框模型 (Box Model) ，包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素

元素框的总宽度 = 元素（element）的width + padding的左边距和右边距的值 + margin的左边距和右边距的值 + border的左右宽度；

元素框的总高度 = 元素（element）的height + padding的上下边距的值 + margin的上下边距的值 ＋ border的上下宽度。

box-sizing : content-box|border-box|inherit;

(1) content-box ,默认值，可以使设置的宽度和高度值应用到元素的内容框。盒子的width只包含内容。

　　即总宽度=margin+border+padding+width

(2) border-box , 设置的width值其实是除margin外的border+padding+element的总宽度。盒子的width包含border+padding+内容

　　　　即总宽度=margin+width

很多CSS框架，都会对盒子模型的计算方法进行简化。

(3) inherit , 规定应从父元素继承 box-sizing 属性的值

关于border-box的使用：

1 一个box宽度为100%，又想要两边有内间距，这时候用就比较好

2 全局设置 border-box 很好，首先它符合直觉，其次它可以省去一次又一次的加加减减，它还有一个关键作用——让有边框的盒子正常使用百分比宽度。

### 2,css3: scrollLeft,scrollWidth,clientWidth,offsetWidth 的区别

offsetwidth:是元素相对父元素的偏移宽度。等于border+padding+width

clientwidth：是元素的可见宽度。等于padding+width

scrollwidth:是元素的宽度且包括滚动部分。

offsetLeft:Html元素相对于自己的offsetParent元素的位置 

scrollLeft:返回和设置当前横向滚动务的坐标值

#### jquery中的width如何计算

　　在JQuery中

　　　　.width返回的是：元素内容width + padding + border.

　　　　.css('width')返回的是：元素内容width + 单位。

　　其实这2个函数分别对应，两种理解元素宽度的方式。

　　　　content-box:元素的宽度就是内容的宽度，不包括 padding 和 border 宽度。

　　　　border-box:元素的宽度直观的就应该是：内容宽度 + padding宽度 + border 宽度。

　　这是一段纠结的历史。

　　在很久很久以前，IE6以前，浏览器是默认 border-box 模型的，后来（就CSS3出来之前）转而默认 content-box，到了CSS3，

二者和谐统一，方法就是CSS3推出一个属性 box-sizing，该属性值有2个：一个是 content-box，另一个就是 border-box。

### 3，为什么会有变量提升

解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间

声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行

### 4， call apply 区别：

call()和bind()的区别：

相同点：都是用来改变this的指向

不同点：call()改过this的指向后，会再执行函数，bind()改过this后，不执行函数，会返回一个绑定新this的函数

call apply 区别：

不同点：参数书写方式不同

call()的第一个参数是this要指向的对象，后面传入的是参数列表，参数可以是任意类型，当第一个参数为null、undefined的时候，默认指向window；

apply()：第一个参数是this要指向的对象，第二个参数是数组

### 5，普通函数和箭头函数区别

箭头函数是匿名函数，不能作为构造函数，不能使用new

箭头函数不绑定arguments，取而代之用rest参数...解决

箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值

箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。

箭头函数没有原型属性

箭头函数的 this 永远指向其上下文的  this ，任何方法都改变不了其指向，如 call() ,  bind() ,  apply() 

普通函数的this指向调用它的那个对象

### 0.1+0.2==0.3

0.1+0.2=0.30000000000000004

解决：(0.1*10+0.2*10)/10 ===0.3

parseFloat((0.1+0.2).toFixed(1)) ===0.3

原因： 由于0.1转换成二进制时是无限循环的，所以在计算机中0.1只能存储成一个近似值。另外说一句，除了那些能表示成 x/2^n 的数可以被精确表示以外，其余小数都是以近似值得方式存在的。

 在0.1 + 0.2这个式子中，0.1和0.2都是近似表示的，在他们相加的时候，两个近似值进行了计算，导致最后得到的值是0.30000000000000004，此时对于JS来说，其不够近似于0.3，于是就出现了0.1 + 0.2 != 0.3 这个现象。



